import { useState, useEffect, useRef, useCallback } from 'react';
import { useSearchParams, useNavigate } from 'react-router-dom';
import { useBookChapters } from '@/hooks/books/useBookChapters';
import { useBook } from '@/hooks/books/useBooks';
import { useBookBlueprint } from '@/hooks/books/useBookBlueprint';
import { useBookCharacters } from '@/hooks/books/useBookCharacters';
import { aiApi } from '@/utils/api/aiApi';
import { useAuth } from '@gaqno-development/frontcore/contexts';
import { calculatePages, formatPageInfo } from '@/utils/pageCalculator';

export type GenerationStep = 'analyzing' | 'generating' | 'expanding' | null;

function parseSummary(summaryValue: string | null | undefined): string {
  if (!summaryValue || typeof summaryValue !== 'string') return '';
  let parsed = summaryValue.trim();
  if (parsed.startsWith('{')) {
    try {
      const obj = JSON.parse(parsed);
      if (typeof obj === 'object' && obj !== null) {
        parsed = obj.summary || obj.content || '';
        if (typeof parsed === 'object') parsed = JSON.stringify(parsed);
      }
    } catch {
      const summaryMatch = parsed.match(/"summary"\s*:\s*"((?:[^"\\]|\\.)*)"/);
      const contentMatch = parsed.match(/"content"\s*:\s*"((?:[^"\\]|\\.)*)"/);
      if (summaryMatch?.[1]) parsed = summaryMatch[1];
      else if (contentMatch?.[1]) parsed = contentMatch[1];
      else {
        const fallback = parsed.match(/"content"\s*:\s*"([^"]*)/);
        if (fallback?.[1]) parsed = fallback[1];
        else parsed = parsed.replace(/^\{[\s\S]*?"(?:summary|content)"\s*:\s*"([^"]*)/, '$1');
      }
    }
  }
  if (typeof parsed === 'string') {
    parsed = parsed.replace(/\\n/g, ' ').replace(/\\"/g, '"').replace(/\\/g, '').trim();
  }
  return parsed;
}

export const useChapterEditor = (bookId: string, chapterId?: string) => {
  const { user } = useAuth();
  const navigate = useNavigate();
  const [searchParams] = useSearchParams();
  const { chapters, updateChapterAutoSave, updateChapter, refetch } = useBookChapters(bookId);
  const { book } = useBook(bookId);
  const { blueprint } = useBookBlueprint(bookId);
  const { characters } = useBookCharacters(bookId);

  const [title, setTitle] = useState('');
  const [content, setContent] = useState('');
  const [summary, setSummary] = useState('');
  const [isGenerating, setIsGenerating] = useState(false);
  const [generationStep, setGenerationStep] = useState<GenerationStep>(null);
  const [currentWordCount, setCurrentWordCount] = useState<number | null>(null);
  const [targetWordCount, setTargetWordCount] = useState<number | null>(null);
  const [hasChanges, setHasChanges] = useState(false);
  const [originalTitle, setOriginalTitle] = useState('');
  const [originalContent, setOriginalContent] = useState('');
  const [originalSummary, setOriginalSummary] = useState('');
  const hasAutoGenerated = useRef(false);

  const selectedChapter = chapterId ? chapters.find((c) => c.id === chapterId) : chapters[0];
  const shouldAutoGenerate = searchParams.get('generate') === 'true' && !hasAutoGenerated.current;

  useEffect(() => {
    if (selectedChapter) {
      const newTitle = selectedChapter.title || '';
      const newContent = selectedChapter.content || '';
      const newSummary = parseSummary(selectedChapter.notes || '');
      setTitle(newTitle);
      setContent(newContent);
      setSummary(newSummary);
      setOriginalTitle(newTitle);
      setOriginalContent(newContent);
      setOriginalSummary(newSummary);
      setHasChanges(false);
    }
  }, [selectedChapter]);

  const handleContentChange = useCallback(
    (value: string) => {
      setContent(value);
      setHasChanges(value !== originalContent || title !== originalTitle || summary !== originalSummary);
      if (selectedChapter) updateChapterAutoSave(selectedChapter.id, { content: value });
    },
    [originalContent, originalTitle, originalSummary, title, summary, selectedChapter, updateChapterAutoSave],
  );

  const handleTitleChange = useCallback(
    (value: string) => {
      setTitle(value);
      setHasChanges(value !== originalTitle || content !== originalContent || summary !== originalSummary);
      if (selectedChapter) updateChapterAutoSave(selectedChapter.id, { title: value });
    },
    [originalTitle, originalContent, originalSummary, content, summary, selectedChapter, updateChapterAutoSave],
  );

  const handleSummaryChange = useCallback(
    (value: string) => {
      setSummary(value);
      setHasChanges(value !== originalSummary || title !== originalTitle || content !== originalContent);
      if (selectedChapter) updateChapterAutoSave(selectedChapter.id, { notes: value || null });
    },
    [originalSummary, originalTitle, originalContent, title, content, selectedChapter, updateChapterAutoSave],
  );

  const handleSave = useCallback(async () => {
    if (selectedChapter && hasChanges) {
      await updateChapter(selectedChapter.id, { title: title || null, content: content || null, notes: summary || null });
      setOriginalTitle(title);
      setOriginalContent(content);
      setOriginalSummary(summary);
      setHasChanges(false);
    }
  }, [selectedChapter, hasChanges, title, content, summary, updateChapter]);

  const handleGenerateContent = useCallback(async () => {
    if (!selectedChapter || !book) return;
    setIsGenerating(true);
    setGenerationStep('analyzing');
    try {
      if (!user) throw new Error('Você precisa estar autenticado para gerar conteúdo');

      const previousChapters = chapters
        .filter((c) => c.chapter_number < selectedChapter.chapter_number && (c.content || c.notes))
        .map((c) => ({
          title: c.title || `Capítulo ${c.chapter_number}`,
          summary: c.notes || c.content?.substring(0, 200) || '',
          content: c.content || undefined,
        }));

      const previousChapter = chapters
        .filter((c) => c.chapter_number < selectedChapter.chapter_number)
        .sort((a, b) => b.chapter_number - a.chapter_number)[0];

      const blueprintChapter = (blueprint?.structure as { chapters?: Array<{ number?: number; chapter_number?: number; title?: string; summary?: string }> } | undefined)
        ?.chapters?.find((c) => (c.number ?? c.chapter_number) === selectedChapter.chapter_number);

      const bookCharacters = characters.map((c) => ({
        id: c.id,
        name: c.name,
        description: c.description || undefined,
        metadata: c.metadata || undefined,
      }));

      let contextualAnalysis: unknown = null;
      try {
        const analyzeData = await aiApi.analyzeContext({
          bookContext: {
            title: book.title,
            genre: book.genre || undefined,
            style: book.style || undefined,
            summary: blueprint?.summary || book.description || undefined,
          },
          previousChapter: previousChapter
            ? {
                number: previousChapter.chapter_number,
                title: previousChapter.title || undefined,
                content: previousChapter.content || undefined,
                summary: previousChapter.notes || previousChapter.content?.substring(0, 200) || undefined,
              }
            : undefined,
          characters: bookCharacters,
          currentChapterNumber: selectedChapter.chapter_number,
          currentChapterTitle: selectedChapter.title || blueprintChapter?.title || undefined,
          currentChapterSummary: selectedChapter.notes || blueprintChapter?.summary || undefined,
        });
        if (analyzeData?.analysis) contextualAnalysis = analyzeData.analysis;
      } catch {
        /* proceed without analysis */
      }

      setGenerationStep('generating');
      const minPagesPerChapter = book?.metadata?.minPagesPerChapter || 5;
      const minWordsPerChapter = minPagesPerChapter * 250;
      setTargetWordCount(minWordsPerChapter);

      const data = await aiApi.generateChapter({
        bookContext: {
          title: book.title,
          genre: book.genre || undefined,
          style: book.style || undefined,
          summary: blueprint?.summary || book.description || undefined,
        },
        chapterNumber: selectedChapter.chapter_number,
        chapterTitle: selectedChapter.title || blueprintChapter?.title || undefined,
        previousChapters,
        previousChapter: previousChapter
          ? {
              number: previousChapter.chapter_number,
              title: previousChapter.title || undefined,
              content: previousChapter.content || undefined,
              summary: previousChapter.notes || previousChapter.content?.substring(0, 200) || undefined,
            }
          : undefined,
        characters: bookCharacters,
        complexity: 7,
        tone: 'engaging',
        useAnalysis: true,
        contextualAnalysis,
        minWordsPerChapter,
      });

      if (data?.wordCount) {
        setCurrentWordCount(data.wordCount);
        if (data.expanded) setGenerationStep('expanding');
      }

      if (!data) throw new Error('Erro ao gerar capítulo. Nenhuma resposta recebida.');

      if (data.error && !data.mock) {
        const msg = typeof data.error === 'string' ? data.error : (data.error as { message?: string })?.message || 'Erro desconhecido na geração';
        throw new Error(msg);
      }

      const generatedContent = data?.content || (data as { mock?: { content?: string } })?.mock?.content || '';
      const generatedTitle = data?.title || (data as { mock?: { title?: string | null } })?.mock?.title || null;
      const generatedSummary = data?.summary || (data as { mock?: { summary?: string | null } })?.mock?.summary || null;

      if (generatedContent) {
        const finalTitle = generatedTitle || null;
        const finalSummary = parseSummary(generatedSummary);
        if (generatedTitle) setTitle(generatedTitle);
        setContent(generatedContent);
        if (finalSummary) setSummary(finalSummary);
        setHasChanges(true);
        await updateChapter(selectedChapter.id, { title: finalTitle, content: generatedContent, notes: finalSummary });
        setOriginalTitle(finalTitle || '');
        setOriginalContent(generatedContent);
        setOriginalSummary(finalSummary || '');
        setHasChanges(false);
      } else if (data?.error) {
        const msg = typeof data.error === 'string' ? data.error : (data.error as { message?: string })?.message;
        throw new Error(msg);
      } else {
        throw new Error('No content generated. Please try again.');
      }
    } catch (err: unknown) {
      const msg = err instanceof Error ? err.message : String(err);
      alert(`Erro ao gerar conteúdo: ${msg}`);
    } finally {
      setIsGenerating(false);
      setGenerationStep(null);
      setCurrentWordCount(null);
      setTargetWordCount(null);
      await refetch();
    }
  }, [selectedChapter, book, chapters, blueprint, characters, user, updateChapter, refetch]);

  useEffect(() => {
    if (shouldAutoGenerate && selectedChapter && !selectedChapter.content && !isGenerating && !hasAutoGenerated.current) {
      hasAutoGenerated.current = true;
      const url = new URL(window.location.href);
      url.searchParams.delete('generate');
      navigate(url.pathname + url.search, { replace: true });
      handleGenerateContent();
    }
  }, [shouldAutoGenerate, selectedChapter, isGenerating, navigate, handleGenerateContent]);

  const pageInfo = selectedChapter ? formatPageInfo(selectedChapter.word_count, book?.genre) : '';
  const chapterPages = selectedChapter ? calculatePages(selectedChapter.word_count, book?.genre) : 0;

  return {
    selectedChapter,
    book,
    title,
    summary,
    content,
    hasChanges,
    isGenerating,
    generationStep,
    currentWordCount,
    targetWordCount,
    pageInfo,
    chapterPages,
    handleContentChange,
    handleTitleChange,
    handleSummaryChange,
    handleSave,
    handleGenerateContent,
  };
};
